= Java2Vhdl translator - tools and example
:toc:
:toclevels: 4
:sectnums:
:sectlinks:
:max-width: 52em
:prewrap!:
:cpp: C++
:cp: C/++
:wildcard: *
:stylesheet: my.css


See also:

* link:Java2Vhdl_Approaches.html[] - Basically information about the concept

* link:Java2Vhdl_TranslatorInternals.html[] - Internals about the implementation

* link:../../deploy/Example1_BlinkingLed-2022-05-26.zip[] A zip file containing an example and link to the tool base.  

//link:Java2Vhdl_StyleGuide.html[] - How to work with Java for Fpga logic

//link:VhdlConv.html[] internal docu how does it work

The next links describe a specific application where this approach is used:

* link:../../../spe/html/SpeA-FPGA/SpeA-JavaFPGA.html[] This is the description of a FPGA design for SinglePairEthernet PHY layer. Work in progress.

* link:../../../spe/html/SpeA-FPGA/SpeA-FPGA.html[] The older description based on only VHDL and Aldec-HDL simulation tool using.
Comparing both descriptions you can also see advantages in the documentation of the behavior of the FPGA.

This is a preliminary information. The tool Java2Vhdl translator is in progress.

== Approach

This document describes the tools for translation Java to VHDL, test at Java level using an example. 

== Working tree organization for sources and tools

Look in the given example `Example1_BlinkingLed.zip`.
The content of this file may be but need not be the template for the file tree organization. 

Generally the idea of the link:../../../SwEng/html/srcFileTree.html[SwEng/srcFileTree.html] is used, a file tree similar as the familiar used maven or gradle file tree, whereas maven or gradle itself is not used here.

----
Path/to/myWorkingTree
 +-src                all sources should be versioned
 +-tools              tools loadable from internet
 +-build              output directory for build outputs (may be in RAM disk, or temp location)
----

The example contains some more files and directories on root level, but this files are really only for the simple example.
It should be assembled with adequate content in a user project inside the src tree.

----
Path/to/myWorkingTree
 +-src
 +-genVHDL_cmp              directory creates the generated files for compare with build
 +- +clean.bat              batch helper file to clean all
 +- +clean_mkLinkBuild.bat  batch helper file to create the build directory
 +- +gen_Vhdl_Example1.bat  batch file for start generation
----

The `tools` and `build` sub directory are created with batch files (Windows-oriented) or adequate shell scripts.
The empty `build` directory will be created and removed by the above shown `+clean.bat` and `+clean_mkLinkBuild.bat`.
This files may be assembled in your user source tree at adequate positions in the `src/...` with adequate content.  

The following files are given, to load the tools from internet, see also link:../../../SwEng/html/srcFileTree.html#libsTools[]
and the following chapter <<#toolsJ2Vhdl>>

----
Path/to/myWorkingTree
 +-src/load_tools
        +-+loadTools.bat   script to create the tools directory and load tools
        +-tools.bom        so named "bill of material" to determine which tools from where
        +-vishiaMinisys.jar  a simple java executable to execute the load 
----

The `src` working tree is organized in the following form:

----
src
 +-main              generally for the application (the main path, maven-like)
 |  +-java
 |  +-vhdl
 +-test              support for test (maven like)
 |  +-java
 |  +-fpga...
 +-load_tools        helper for the tools, not in maven concept.
----

`main` and `test` separates between the product relevant files (in `main`) and test files. 
The next level below `main` and `test` is the kind of source files, here Java files or some VHDL files, or other if necessary.
C and {cpp} files, maybe necessary for other parts of the whole project, are usual stored in a `cpp` subdir. 
`fpga...` is a hint to any other test files, user specific.

The level below should be determined by the components directory, see also link:../../../SwEng/html/srcFileTree.html#components[].
For our example and tools we have:

----
src
 +-main
 |  +-java
 |     +-srcJava_vishiaFpga              common necessary Java sources from vishia
 |     +-srcJava_FpgaExmplBlinkingLed    the specific user sources, here the example 
 +-test
    +-java
       +-testJava_FpgaExmplBlinkingLed   the specific test sources, here the example
----       
       
It means, if you want to use Eclipse as environment for Java development (recommended),
you need three linked folders to work.
For organization of eclipse projects, see also link:../../../SwEng/html/EclipseWrk.de.html[] (unfortunately yet only in German).

Inside the Java components you have the familiar Java package tree, starting in this case all with `org/vishia`.
The Java package tree is familiar since the first Java development in the 1990^th^.
It is a world wide unique deterministic of packages using the revers internet address as first members.
Hence all parts which are developed related to the link:https://www.vishia.org[] web page (Java related parts) 
are denoted in the `org/vishia/...` package tree. For your own you should use your web presence as start path
such as `com/siemens/department/...` if you are from the Siemens company or `com/bosch/department/...` if you are working in the Bosch company 
or whatever else, as usual in your company. This should be only understand as hint or notice, may or may not be important.  



[#toolsJ2Vhdl]
== Tools necessary for Java to Vhdl translation and test support

The necessary tools for Java to VHDL translation are really less. It is only jar files to work with Java.

Java itself should be familiar for usage. This examples and tool files are related to the long term provided Java-8 version from Oracle,
but also some open source Java may usable. 

After loading the Java files from the internet via clicking on `src/load_tools/+loadTools.bat` you get the following files to work:

----
2022-05-23  14:14               502 +loadTools.bat
2022-05-23  14:48               584 tools.bom
2022-05-23  14:49         1.500.128 vishiaBase.jar
2022-01-24  20:25            81.128 vishiaMinisys.jar
2022-05-23  14:49            56.282 vishiaVhdlConv.jar
               5 Datei(en),      1.638.624 Bytes
---- 

If you look on `src/load_tools/tools.bom` you see the following:

----
include::../../../load_tools/tools.bom[]
----

This textual file is executed by the Java class `org.vishia.minisys.GetWebfile` which is contained in the here also registered `vishiaMinisys.jar`.
It contains the internet location for the jar file, the destination file name and a MD5 checksum. 
You can do this actions also manually, build and compare the check sum. The files are able to view and load in the given location,
this is link:https://www.vishia.org/Java/deploy[]. 
You find also the source files beside the jar files with the same name, only with the extension `-source.zip`
All is open source, you can study the algorithm, and also compile it newly. The source-zip archive contains a `_make` directory. 
You should only place all depending jar files or sources (that is here `srcJava_vishiaBase`) side beside. 
Depending jar files should be placed in a `tools` directory beside:

After newly translation you get the same jar files with exactly the same binary content and hence the same check sum.
This is the approach of reproducible build, see also link:../../../Java/html5/source+build/reproducibleJar.html[]
and also link:https://reproducible-builds.org/reports/2020-03/[].
It means you can both check the correctness of the MD5 check sum and check whether the sources are really valid for the given binary.

As you see, the VhdlConv itself is only a small file consist of a few Java classes. No more is necessary. 
But the basics, independent of the VHDL approach, the Parser, text generator etc. are all contained in the `vishiaBase.jar`.
But this file has also only 1.5 MByte. The other used tools are only the Java-8 system from Oracle. 
No other tools and executables are used. Nothing is stored in any temporary or `home/user` locations.
Getting the core of the job done usually doesn't require sprawling tools.

== The platform to edit the Java sources for VHDL

It is recommended to use Eclipse, but also another IDE is possible as your choice.

You can also use any text editor to view the sources.

To compile and run the example independent of an IDE you can use the batch file compilation.
But you need he `javac` compiler (part of JDK, Java Development Kit, link:https://www.oracle.com/java/technologies/downloads/[].

Look at `src/main/java/srcJava_FpgaExmplBlinkingLed/_make/+makejar_exmplBlinkingLedFpga.sh`.

The compile result will be written in the `build` folder. From there it can be run starting `src/test/bat/test_Example1_BlinkingLed.bat`.
This is for your experience.


== The translation Java to VHDL

This is only the start of a command line execution, for the example:

----
 java -cp tools/vishiaBase.jar;tools/vishiaVhdlConv.jar org.vishia.java2Vhdl.Java2Vhdl -sdir:src/main/java/srcJava_FpgaExmplBlinkingLed -sdir:src/main/java/srcJava_vishiaFpga org.vishia.fpga.exmplBlinkingLed.fpgatop.BlinkingLed_Fpga -o:build/BlinkingLed_Fpga.vhd -tmp:build/ -rep:build/BlinkingLed2Vhdl_report.txt
----
 
This is a very long line because of the arguments, not obviosly.
Therefore a better solution is possible, given in the example:

----
java -cp tools/vishiaBase.jar;tools/vishiaVhdlConv.jar org.vishia.java2Vhdl.Java2Vhdl --@%0:convArgs 
REM info: one space after the label, then trim all trailing spaces also without comment
::convArgs ##             
::-sdir:src/main/java/srcJava_FpgaExmplBlinkingLed            ##source dirs from current
::-sdir:src/main/java/srcJava_vishiaFpga  
::-top:org.vishia.fpga.exmplBlinkingLed.fpgatop.BlinkingLed_Fpga   ##top level file to translate in first source dir
::-o:build/BlinkingLed_Fpga.vhd                               ##output
::-tmp:build/  
::-parseData                                                  ## The java data tree to view
::-parseResult                                                ## The parse result list
::---parseLog                                                 ## an elaborately parse log
::-rep:build/BlinkingLed2Vhdl_report.txt                      ##report with meta information
pause
----

General with the argument `--@path/to/argfile` some arguments can be read from a file. 
Whereas each line of the file is one argument. That makes it also possible to use white spaces in arguments without quotation marks. 
But often an extra file for that is not nice. 
With a label after the argfile path after colon the argument processor searches this label in the argument file.
The label should be places on beginning of the line, but after maximal 5 comment characters.
The comment characters then must be written also leading before the arguments in the line. 
This helps to separate comment lines from other content in any file, in this case in the batch file itself.
The first line without these comment character, here the `pause` line is then the termination of argument lines.
Additionally the arguments can be commented with the comment character given after the label. 
One space between label and argument comment characters forces removing trailing spaces in the line, which is often sensible but not at all.
Hence it can be controlled here.

With this argument designation the arguments are well readable.

A short explanation of the arguments comes if the converter is started without arguments:

----
Java2Vhdl made by HSchorrig, 2022-02-16 - 2022-05-31
 see www.vishia.org/Fpga/html/Vhdl/Java2Vhdl_ToolsAndExample.html
-i:path/to/template.vhd  ...optional, if given, read this file to insert
-o:path/to/output.vhd
-top:pkg.path.VhdlTopModule ... the top level java file (without .java, as class path) 
-sdir:path/to/srcJava  ... able to use more as one
-sl ... optional, if given, remark src and line
-parseData ... optional, if given, writes the parser java data tree
-pd ... optional, same as -parseData
-parseResult ... optional, if given, writes the parser result
-pr ... optional, same as -parseResult
-parseLog ... optional only with -parseResult, writes an elaborately parser log file
-pl ... optional, same as -parseLog
-tmp:path/to/dirTmp for log and result
-rep:path/to/fileReport.txt   ... optional
---- 

This is of course only a short description, with the link to this document. 

* The `-i:path/to/template.vhd` can be used if only a part of the VHDL file should be generated, 
the frame is given with this file. The generated parts are firstly the `TYPE ... RECORD` definitions and the `SIGNAL ....:_REC` instances, `
and secondly the `PROCESS` . The given file should contain labels in the following form:

----
  ...start of the file, with heading, ENTITY, Ports
ARCHITECTURE BEHAVIORAL OF ....
  
-- INSERT Java2Vhdl
  ... This parts are replaced by the new generated one TYPE ... RECORD definitions
  ... and SIGNAL ....:_REC` instances
-- END Java2Vhdl
  ... further content, SIGNAL and COMPONENT definiton, especially the 
BEGIN
  ... and more given content
-- INSERT Java2Vhdl
  ... This parts are replaced by the new generated processes
-- END Java2Vhdl
  ... finishing content
----

* `-o:path/to/output.vhd` is also used if `-i:...` is given. It means the `-i:...` file will not be replaced, only read.
It may be recommended to generate a new file first to a temporary location in the file system, and then compare because of changes,
at least replace.

* `-top:pkg.path.VhdlTopModule` This is the class path with package path of the top level Java class for the FPGA design.
Usual this class contains a `class Modules` inner class to determine all other sub modules.

* `-sdir:path/to/srcJava` This argument can be given more as one (usual) as search path for the Java files.
It contains the directory where the Java package path starts (with `org/...`), not the directory of the Java file itself.

* `-sl` means "source line". If given then in the generated `-o:...` file the source file and the line of the Java source 
for the appropriate generated VHDL line is written as `---path/to/src: line`. This helps to associate generated lines and Java source lines.
However, using this feature makes it a little bit difficult to compare a newly created file 
with the previous version because often the lines are shifted in the source, hence only all the line numbers are changed. 
It makes really changes lesser obviously. It may be recommended to generate both versions, with and without this option, 
and store both as second source, without line numbers for a simple version comparison and with line numbers to search assiciations with the Java sources.

* `-tmp:path/to/dirTmp` It is possible to output intermediate files for parsing results etc. especially during development, 
not used in the compiled version.

* `-rep:path/to/fileReport.txt` This is an interesting report file about modules, interfaces, variables and should be stored
beside the VHDL output file. 


== The component srcJava_vishiaFpga

This component contains some Java files. They are necessary in a user's project for test and for using annotations and call specific operations.
It means this component should be used as source file tree.
It is located for the example.zip in:

----
src
 +-main
   +-java
      +-srcJava_vishiaFpga
         +-org/vishia/fpga
                       +-stdmodules/*.Java     useable in the design
                       +-testutil/*.Java       useable for test on Java level
                       +-Fpga.java             define some standard operations and annotations
                       +-FpgaModule_ifc.java   the essential module interface
----

You don't need (must not) change the content of these files, only use it. It is also versioned (yet TODO Github)


== The example Blinking LED, view to Java sources in respect to the FPGA description

This is a study example or template for your own. 
The sources are located for the exmaple.zip in:

----
src
 +-main
   +-java
      +-srcJava_FpgaExmplBlinkingLed
         +-org/vishia/fpga/exmplBlinkingLed    This should be your own package path for other projects
            +-fpgatop/*.java
            +-modules/*.java
            +-test/*.java                      only for test on Java level, may be in test folder, see next chapter
----

The content of the files are partially described already in the approach document regarding interface concepts etc.

link:Java2Vhdl_Approaches.html[]

This chapter describes it from the view of the template for your own.

[#toplevel]
=== The top level FPGA java file

All following code snippets comes from the `main/java/srcJava_FpgaExmpl.../fpgatop/BlinkingLed_Fpga.java`.

[#topclass]
==== Package and class definition, import

In Java always the name and path of the file itself should match to the package declaration and name of the only one `public` class inside the file:
The Java file starts with the package declaration. The package names and also the appropriate directories on the file system 
must be written starting with a lower case character.

.Java: top level class definition
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=theClassDef]
----

The `import` statements name all used classes from other packages. It is possible to use an asterisk to select all Files in the package. 
But then the dependencies are not well documented. In this case anyway all files in the 'exmplBlinkingLed.modules' package should be part of,
then it is ok.

The module class should implement the `FpgaModule_ifc`. That is all necessary. This interface defines:

.Java: FpgaModule_ifc definition as basic interface
[source,Java]
----
include::../../../main/java/srcJava_vishiaFpga/org/vishia/fpga/FpgaModule_ifc.java[tag=classhead]
include::../../../main/java/srcJava_vishiaFpga/org/vishia/fpga/FpgaModule_ifc.java[tag=body]
----



[#topModules]
==== The modules in the top level 

The class definition continues with the 

.Java: used modules in the top level
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=Modules]
----

The modules are aggregated together as described in link:Java2Vhdl_Approaches.html#aggr[Java2Vhdl Approaches, chapter More possibilities with Java2VHDL: References (aggregations) in Object Orientation kind].

Because you can generate a __Javadoc__ it is recommended to comment all modules in the given style (here not all are commented). 
But also a non commented style is sufficient because you can use cross referencing in the IDE.

The modules should be connected immediately here, either on instantiation with a parameterized constructor, or with the `init(...)` operation
in the constructor of modules. It depends on circular referencing whether the immediately referenced instantiation can be done. 
That is more simple. But using `init(...)` has more flexibility. 

Firstly in this class the `ioPins` are defined. This is done in an extra class, see next chapter. 

The writing style with the explicitly `this` is recommended. `this` is also implicitly accept (can be omitted), but then the relations are worse documented. 
The `BlinkingLed_Fpga.this` writing style is necessary for the translator. 
`BlinkingLed_Fpga.this` is the reference to the environment class. Java can automatically detect this relation, 
it checks whether the following identifier is able to find either locally, or in the own class, or in all environment classes.
This is more error prone because of confusion in identifier usage. 
Hence the dedicated writing style `EnvironmentClass.this` prevents the confusion. For the Java2Vhdl translator it is also more simple. 

[#topstep]
==== step(...) and update() operations

Following the both routines are defined:

.Java: top level class step update
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=step_update]
----

See also link:Java2Vhdl_Approaches.html#stepupd[]

Both routines should call all `step(time)` and `update()` of all sub modules. The `time` comes from the simulation environment
useble for time checking, see link:Java2Vhdl_Approaches.html#timeCnstrn[] and for signal output, see link:Java2Vhdl_Approaches.html#testOutp[].

[#topifcacc]
==== interface agents in the top level

The so named __**interface agents**__ are anonymous class definitions as interface implementation to access data in this module.
They are usable for referencing. 

.Java: top level class interface agent/access
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=time_BlinkingLed_ifcAccess]
----

In the top level they should be used either for stubs instead not implemented modules, for test designs or variations,
but also for parameter of modules which should be determined in the top level. This is shown above. 
The interface access implements a `...Cfg...` interface for configuration parameters. 
It is used as reference for the [J]`ct(..., BlinkingLed_Fpga.this.blinkingLedCfg,...` module, see chapter <<#topModules>>


[#toptest]
==== test output in the top level

The top level does not need test output if it has no own PROCESS sub classes. 
The output preparation for the main level can be done immediately in the test environment, see chapter <<#addSignalsMain>>.
This has no meaning for the Java to VHDL translation, writing this stuff to the test java file unburdens this file for translation.



[#ioPins]
=== The FPGA pin description file

It is a good idea to separate the Pin description source file from the top level file,
because different inner FPGA designs can use the same pinning. 
This is typical if you have a hardware board with a given layout, but the content of the FPGA should be varied.
Then you need define the pinning only one time for the given layout.

Furthermore it is also possible to have more as one top level FPGA file for different parts,
but you should have only one file for the pinning, because this is board layout related.

==== How to designate the ioPins file

The pin description file should be designated as [J]`ioPins` in the [J]`Modules` class of a top level:

.Java: ioPins definition in the top level
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=ioPins]
----

See also chapter <<#topModules>>.
The designated class file is searched and translated especially for IO pinning. 

 

The ioPins file starts due to Java conventions with

.Java: BlinkingLed_FpgaInOutput class definition head
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_FpgaInOutput.java[tag=classdef]
----

==== Input and Output inner classes

For this example the pin classes are short, for more pins it is a little bit more, very simple:

.Java: BlinkingLed_FpgaInOutput Input and Output
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_FpgaInOutput.java[tag=InOutput]
----

* If the same pin should be used both as input and output, then the same pin name should be defined in the [J]`Input` and in the [J]`Output` inner class.

* If a pin should have tristate character (often necessary on input/output switch), it should be designated as [J]`char` type
and set with [J]`'0'`, [J]`'1'` and [J]`'Z'`. (TODO for the 2022-05 version).

* The Input pins can be declared as __package private__ (without designation) if an interface access is defined here also to set the pins. See next chapter. Elsewhere they can be designated as [J]`public` for simple set accesses for tests.

* Output pins should be declared as [J]`public` for immediately access for test and to set from the different top level FPGA java file maybe in different packages.

The output pins are written immediately in the [J]`update()` operation on the top level:

.Java: top level class using interface implementation and simple access operation for output
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=outPins]
----


==== Interface access to the Input pins

The input pins are usual accessed via interface references from view of a module. 
Hence the link:Java2Vhdl_Approaches.html#IfcAccess[] should be defined in a proper way for all input pins.  
For specific pins a specific interface also with more as one bit can be used. For common ordinary pins the following simple interface is sufficient:

.Java: Bit_ifc
[source,Java]
----
include::../../../main/java/srcJava_vishiaFpga/org/vishia/fpga/stdmodules/Bit_ifc.java[]
----

In this example only the access to the only one [J]`reset_Pin` is necessary

.Java: BlinkingLed_FpgaInOutput Interface access
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_FpgaInOutput.java[tag=ifcAccess]
----

This uses the [J]`Reset_Inpin_ifc` as used in the accessing module `org.vishia.fpga.stdmodules.Reset`, 
see the [J]`Modules` definition in the top level file.

To set this inpin a set operation is necessary because of the non public property of the pin variable.
It is a good decision for overview (divide and conquer) to write this set operation in an extra file, but in the same package:

.Java: BlinkingLed_IoAcc for test, the whole file:
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_IoAcc.java[]
----




[#mdllevel]
=== A module file

All following code snippets comes from the 
`main/java/srcJava_FpgaExmplBlinkingLed/
org/vishia/fpga/modules/BlinkingLedCt.java`.

[#mdlclass]
==== Package and class definition, import and module interface

The principles in Java are already explained in <<#topclass>>.

.Java: module class definition
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=theClassDef]
----

Here the advantage of dependency documentation of the `import` statements are shown. 
In opposite to {cp} programming where the dependencies are documented with included headers, the used modules are immediately obviously.
In {cp} maybe hidden dependencies may be existing because an header can include other headers, 
and the association between header and implementation files is weak. 
In Java it is strong, clarified and obviously.

You see that external dependencies exists to one of standard modules, to test utils and to a special class for String preparation, 
which is used for test output. 

The module class implements the `BlinkingLed_ifc` which is a module interface, see 
link:Java2Vhdl_Approaches.html#IfcModule[], the implementation is shown in the chapter <<#mdlifcimpl>> 

[#mdlAggr]
==== The references and sub modules of the module 

The class definition continues with the 

.Java: module class references
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=Ref]
----

The meaning and the writing style of the references is also explained in link:Java2Vhdl_Approaches.html#aggr[].

Also there is explained how the references are set. It is the same example.

A module can also have sub modules to build a deeper tree of modules. It is adequate to the top level.
(TODO 2022-05 not tested, should work)

[#mdlPrc]
==== Inner static classes in a module which builds a TYPE RECORD and PROCESS in VHDL

The following code snippet shows one PROCESS as a whole. 

.Java: module PROCESS class and instances
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=Prc]
----

This is the core functionality for VHDL and hence explained elaborately:

* The inner class should be marked with the [J]`@Fpga.VHDL_PROCESS` annotation to detect as such from the Java2Vhdl translator.
* Variables in the inner class are generated in a type record with the class name:

----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=BlinkingLedCt_Q_REC]
----

* Variables started with [J]`time` are ignored for VHDL conversion, there are for timing test on Java level.
* `SIGNAL` definitions in VHDL with the `TYPE RECORD` (instances for this `RECORD`) are not created 
because of the module PROCESS class definitions.
Instead, they are defined only if the module class is used, and then with the module(s) name(s). 
It is possible to have a module more as one time, then also more SIGNAL ... RECORD variable are defined. 
Here for the usage in the `fpgatop/BlinkingLed_Fpga.java`:

.Java: top level part of Modules definition:
[source,Java]
----
  public class Modules {
    .... 
    public final BlinkingLedCt ct = new BlinkingLedCt(....
----

.Vhdl: SIGNAL definition for this PROCESS of a module:
[source,Vhdl]
----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=RecordSignals]
----

* You can see in the mid of this three signals the module name [J]`ct` from the module definition in [J]`Modules`
combined with the name of the Process [J]`Q`. If you have more PROCESS classes in a module, of course you have more TYPE RECORD definitions
and also more appropriate SIGNAL definitions. 

* The constructor [J]`Q() {...}` is only for Java test. 
It is (should be) related to the reset behavior of the FPGA: Signals are reset to 0-level.
A specific reset behavior is not provided. It is also not full clarified in VHDL, depends on FPGA types.
The 0-initialization is anyway applicable. For specific reset behavior the following process should use a reset signal functionality.

* The constructor [J]`@Fpga.VHDL_PROCESS Q(Q z, Ref ref) { ...` now describes the process for VHDL translation and also for simulation.
It should/could have the following arguments with fixed naming conventions:

** [J]`int time` reference to a time value used for timing test in Java, not used for VHDL 
** [J]`z` of the same type: It is the previous state for calculation, comes from the current state in step.
** [J]`ref` reference to the [J]`Ref` class of this module, to access referenced modules.
** [J]`mdl` reference to the whole module class (set with [J]`this` on call, see next chapter).
** [J]`in` reference of a [J]`Input` class of the module for a simple wiring without references.
** [J]`out` reference to an [J]`Output` class of this module, more exact to the `_d` instance (prepared values). 
This allows the simple wiring and [J]`public` access in Java.  

* The PROCESS inner class is `private`, should be used only in this module and not accessed from outside. 
The elements are __package private__ (without designation in Java). 
It can be accessed anyway only in this module because of the `private` nature of the class. 

* The content of this constructor is immediately translated to the VHDL PROCESS. To see it for this example look on the translated code:

.Vhdl: PROCESS due to the BlinkingLedCt.Q constructor:
[source,Vhdl]
----
include::../../../test/testResult_Ref/Java2Vhdl/BlinkingLed_Fpga.vhd[tag=ct_Q_PRC]
----

** Variable with [J]`time...` are ignored for VHDL, they are for timing checks in Java.
** Variable which are set with the same [J]`z.` variable are ignored for VHDL because this is the standard behavior for VHDL:
Not assigned variables preserve there values. But that assigments are necessary for Java.
** Because all variables should be [J]`final` a complete unique assignment of all variables is necessary for Java. 
This helps preventing errors on forgotten not clarified functionality:
** Because you should write [J]`this.var = z.var;` in Java
it is clarified in the Java source that this is an unchanged value. 
The place and route for the FPGA can use either the own Q output of the FF for the logic, or can work with the CE (clock enable) input
for the FF groups.
** You cannot forget variables, because Java checks setting of all [J]`final` variables.
** Tip for writing sources with final variables: You can firstly remove all [J]`final` keywords, set it one after another. 
Then the error messages for missing final are obviously step by step. You can set an assignment [J]`this.var = z.var;`
in all branches, then set the variable to [J]`final`, 
then you get an error message on this positions where the variable is defined twice. 
Remove it and think about correct assignments due to the requested logic. At least you have all variables [J]`final` and no errors. 
** If you use already assigned [J]`this.` variables on the right side for an assignment, this would be the value of the D-input of an FF.
VHDL suggests using an internal variable for that. In the moment (2022-05) this is not regarded, but can be implemented in the Java2Vhdl translator.
 
How statements and expressions are translated, see link:Java2Vhdl_TranslatorInternals.html[].

* At last in the Java example with [J]`private Q q = new Q();` and [J]`private Q q_d;` two references for instances are defined.
** The [J]`q` reference must have the same name as the PROCESS class, only start with a lower case character. Here it is only one character.
This reference is used to access to the RECORD instances in VHDL both on [J]`public` immediately definition of this reference (possible)
and also for interface accesses. 
** In this example the reference [J]`q` is [J]`private`. 
This means that you can be sure that there is no direct access from outside, both for the Java source level and for the VHDL record type.
** The [J]`_d` instance is not used for translation and should only accessed in the [J]`step(time)` and [J]`update()` operations.
It holds the prepared D-input values of the FlipFlops. It should be anytime [J]`private`
** Note that Java knows for class instances only references (other than in {cp}). All is a reference. The instances are organized in the heap.



[#mdlStep]
==== step(...) and update() operations

The step and update in a module should call the process execution. 
It is not used for the VHDL translation, but for the test.

.Java: module class step and update
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=step_update]
----

See also link:Java2Vhdl_Approaches.html#stepupd[]

You see here how does it work:

* [J]`step(time)` creates new instances of all process variables with new combinatoric values and stores it in the [J]`private ..._d` instance.
Therefore, it is blocked for third-party access. Other modules should use only the Q-state of the FlipFlops to preserve the exact timing.
All [J]`step(time)` routines of all modules are executed firstly before [J]`update()`

* [J]`update()` stores all prepared D-values in the real used instances for all immediately and interface accesses. 

It means, any step in Java creates a new instance. The instance is allocated in the heap. If you have 120000000 steps for the BlinkingLed example,
the Java simulation creates 120000000 instance of any PROCESS class type for any used module. 
The simulation runs on a Notebook with normal modern equipment approximately 5 seconds, no more. 
It needs approximately 0.3 GByte RAM (measured with the Task Manager on Windows-10). It means Java can proper deal with this request.

If sub modules are present, of course this should be also called here. 

[#mdlifcimpl]
==== interface implementation of the module

The next code snippet shows two accesses:

.Java: module class interface implementation and simple access operation
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=mdlifcimpl]
----

The first operation with the annotation [J]`@Override` overrides the declaration in the [J]`BlinkingLed_ifc`, see chapter <<mdlclass>>.
It is used on the top level of the FPGA for the outputs in the `update()` operation of the top level in the first line, see code snippet below.
  

The second operation with the annotation [J]`@Fpga.GetterVhdl` is an access operation without an interface. 
It means it cannot be used as univeral access, only for this module. 
Hence it is not proper for an input reference of another module, because then another implementation and therefore access via an interface is necessary.
But this operation is usable both for specific test outputs on the FPGA and to build output values only for the module specific implementation.
It is used on the top level of the FPGA for the outputs in the [J]`update()` operation of the top level in the last line:

.Java: top level class using interface implementation and simple access operation for output
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/fpgatop/BlinkingLed_Fpga.java[tag=outPins]
----



[#mdlifcacc]
==== interface agents or access in a module

The so named __**interface agents**__ are anonymous class definitions as interface implementation to access data in this module.
They are usable for referencing. 

.Java: module class interface agents/access
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=mdlifcacc]
----

See the example in the top level, chapter <<#topifcacc>>
In this case the interface access is used for the output, see the last code snippet in the chapter above: 'top level class using interface implementation and simple access operation for output'.

The implementation accesses the [J]`ct` variable in the [J]`q` instance of the module class. 
The writing style [J]`BlinkingLedCt.this.` means in Java the access to the (named) environment class.
For debugging this reference is shown as `this$0` whereas `this$1` etc. are higher level environment classes. 
In Java this can be omitted, but then it is lesser obviously. For the Java2Vhdl translator it is (yet 2022-05) necessary to write.

[#mdltest]
==== test output

The module source.java is continued with 

TestSignalRecorderHead

.Java: module class TestSignalRecorder class definition
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=TestSignalRecorderHead]
    ....
  }
----

This class is not used for the VHDL generation, but used for test. It is explained in the next main chapter. 

 
[#JavaSrcTest]
== The example Blinking LED, view to Java sources in respect to test on Java level

If you want to separate test files (with a lot of complicated test cases) from the sources, 
you can also place the test Java files in 

----
src
 +-test                                        use the test sub folder
   +-java
      +-testJava_YourComponent
         +-package/path/your/component         This should be your own package path for other projects
            +-test/*.java                      only for test on Java level.
----

But for this simple example the test class is part of the same Java source tree:

----
src
 +-main
   +-java
      +-srcJava_FpgaExmplBlinkingLed
         +-org/vishia/fpga/exmplBlinkingLed
                            +-test/*,java    only for test on Java level
----

The test classes offers test cases/pattern and checks. 

The source code of the modules offers Test output signal generation functionality which are universal usable for the tests.

=== The main test source

==== Class definition and instances to test and used for test

Look firstly to that `org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java` which contains the [J]`main` start routine:

.Java: main test routine class definition
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java[tag=classDef]
----

You see on the depedencies ([J]`import` statements) that the test does not need knowledge about the modules.
This is because the test signals are built independently in the modules, the access is via the [J]`TestSignalRecorder` interface.

On top of the test class the [J]`BlinkingLed_Fpga fpga = new BlinkingLed_Fpga();` FPGA top level is instantiated one time.
It is also possible to instantiate more as one FPGA to check interaction. 
It is also possible to instantiate here some simulation replacements for environment hardware, all what's necessary.

If this is a module test class, then the module(s) should be instantiated here with their test environment (test bed).

[#outHmain]
==== Instantiate a horizontal output recorder

The horizontal output recorder is an instance of link:../../docuSrcJava_vishiaFpga/org/vishia/fpga/testutil/TestSignalRecorderSet.html[].


.Java: output recorder instance and definiton in start of a test routine
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java[tag=outH]
----

The instance should be created new in any test routine for that test outputs.
After them the desired link:../../docuSrcJava_vishiaFpga/org/vishia/fpga/testutil/TestSignalRecorder.html[TestSignalRecorder] 
instances of the modules should be added.
One module can have more as one instances of [J]`TestSignalRecorder`. 
They are used to compile the desired output information. 
For different test cases you can get just different output information.

The detailed content of the output information is determined in the modules itself, see the chapter <<#addSignalsMdl>>.

[#TestOrg]
==== Organization of a checked test

The next line shows only the creation of a test check support class, see link:../../../Java/docuSrcJava_vishiaBase/org/vishia/util/TestOrg.html[org.vishia.util.TestOrg].

.Java: Instance of TestOrg in the test routine
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java[tag=TestOrg]
----

This class helps to organize some tests with a concise output for automatic test case evaluation.


[#initStimuli]
==== Initialize stimuli (signals) for the simulation

This are the initials settings of all input pins. It can be set either immediately or via interface operations.

.Java: Initialization stimulis / signals
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java[tag=initStimuli]
----

For this example only the reset pin is used. For the test it is hold to inactive high during the whole operation. 
The functionality of the reset pin itself can be tested with another programmed test, or is already tested using the [J]`reset` module in other contexts.
Hence, it is not important here.  


[#runSimul]
==== Run the simulation for this test case

In the simulation loop all FPGA simulations and also conditions of inputs to the FPGA which are not constant (depends on outputs, own stimuli signals)
should be calculated. 
The basic step time is the clock. 

.Java: statements to run the test
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java[tag=runSimul]
----

To simulate the FPGA(s) the appropriate [J]`step(time)` one after another and after them all [J]`update()` should be called. 
After [J]`update()` the preparation of inputs to the test bed can be gotten from FPGA outputs of this step time.
The test bed calculations can be done then in the next loop as first before the [J]`fpga.step()`. 
Here nothing else is to do. 

Also after all updates the [J]`outH.addSignals(time)` is called to record all signals in all modules,
organized in the [J]`outH` of type [J]`TestSignalGeneratorSet`, see sub chapters above.

Here it is shown that the [J]`addSignals(...)` is conditionally called only [J]`if ...ce`. 
This means that the output signals are not resolved down to the individual clock level. 
The [J]`ce` is the central clock enable for the most module functions,
and only outputs regarded to this [J]`ce` are in focus. This may be important for longer runinng tests, such as here for more as 100 million steps.
Usual, if the signals on any clock edge are interesting, the simulation time is lesser and focused on module functionality.
This is not a principle approach, it is sensible.

[#outputRecording]
==== Output recorded signals

The output of the recorded signals is only a simple writing of all StringBuilder registered in the [J]`TestSignalRecorder`
in the order of registering. The output written to a text file can be edited for presentation also afterwards.

.Java: output signals of horizontal recording usual for manually elaboration
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java[tag=outRecording]
----

It is also possible to produce output signals in a file with vertical recording (one line is one time stamp, signals in the line).
This is not shown here yet. Especially this format can be converted to a signal graphic similar as the output of FPGA simulation tools,
with the possibility of zoom etc. 


[#testEval]
==== Automatically evaluation of test results

In the next code snippet two output lines of the horizontal signal recording are checked.
The special function [J]`checkOutput(...)` as specific implementation for the check tests the pattern in the line:
The signals should be a minimal and a maximal number written one after another. The evaluation starts after the first change,
not from beginning, because elsewhere the minimal number of characters may be violated. 

.Java: evaluation of test results for automatically test
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java[tag=testEval]
----

This test is programmed done. It produces with the following [J]`test.finish()` a concise state "__Test ok or ERROR__" 
which can be simple automatically evaluated. It means this and more tests runs, and the result should be "__ok__" for all tests.

With this approach it is possible to test whether the functionality is proper (for the test cases) after some changes in the sources.
May be specific changes were done, and the results were checked manually.
But now the question arises: Has the change side effects? Is everything else still running?

To answer this, such tests, which can be elaborately, are important. 

Of course, the test cases, the stimuli and the evaluation can also be faulty or incomplete.
In conclusion, the effort for the test cases is often higher than the effort for the functionality itself.
It depends on the type of use (long-term or intermittent) whether this expense is appropriate.



[#testMain]
==== The main routine for test

The main routine is called immediately from command line level. 
It creates the own class, and starts some tests. 

The top level [J]`TestOrg` assembles all children [J]`TestOrg` for more tests and a summarized evaluation.

.Java: TestSignalGenerator implementation complete for conditional output
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java[tag=main]
----

Generally a [J]`try ... catch` should be present to catch non expected exceptions. 
With the stack trace the reason may be able to find also in non debugging environments. 
For example any uninitialized stuff may cause a null pointer exception which is not necessarily a flaw in the logic, only a small programming mistake.
In general, Java's try-catch capability is well proven.


[#addSignalsMain]
==== Test output preparation for the main level

This is the contribution of test signal output from the main test or the whole fpga to view and also for automatically check the results.
This top level output test results is not implemented in the top level FPGA java file (here `BlinkingLed_Fpga.java`), 
instead in the test routine, to unburden the top level java file. 
The access to the Pin signals is anytime possible in a public way, in opposite to the situation in the modules, see next chapter.    

The code snippet shows the complete [J]`TestSignalRecorder`

.Java: TestSignalRecorder implementation complete for conditional output
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/test/Test_BlinkingLed.java[tag=TestSignals]
----

* The Recorder should define StringBuilder for each test signal for store and output, here two lines.
* The [J]`char cLed...` are only locally, it stores the values for complete the lines in [J]`endSignals(...)`.
* The constructor has the name of the module as parameter. The hint in the comment is for the order, see chapter <<#outHmain>>.
* The [J]`clean()` operation should be overridden in the shown kind, should register the locally [J]`StringBuilder` calling [J]`registerLine(...)`.
* The [J]`addSignals(...)` operation is subordinate here, it writes the state of the Led output pins, but only if another module,
here it is especially [J]`BlinkingLedCt` has written something. This is sufficient, because the Led signal is slow and long. 
The other module produces enough time stamps to see what happens. But such decisions depends heavily on the test case.
Hence the output should tuned to the test case. On the other hand the test cases are often similar in output requirements.
* The [J]`endSignals(...)` is here overridden to produce the repeated character for the LED. The standard implementation writes a space
to separate hexa values, which is often the requested use case. 


[#testRecordingMdl]
=== Test support in modules

The decision which signals are to be output for the display of the test results can only be made in a module itself, since only the module knows its own signals. 
This is often seen in a different way, namely that the test case itself should determine which signals should be displayed. 
However, this assumes that the signals are known and not changed. It also violates the private/public encapsulation of content in modules.

But of course the decision which signals to display may depend on the particular test case. 
For such possibilities more as one [J]`TestSignalRecorder` inner class can be implemented. 
The implementation can be done due to a specialized test case, but should be designed in a more universal way. 
The question is which signals are interesting, for a detailed look at the module - or to get an overview.
The structure of the module, not the specific opinion of the tester, should be determinative. 


[#addSignalsMdl]
==== Determination of information to record for output horizontal

For this example a specific detail is programmed in the next code snippet:
It is the elaborately view to the time spread where the low-bit counter overflows and triggers the high-bit counter. 
All other occurrences are irrelevant, they are clarified. 
This is the interesting point in the module, and may be also the interesting point for a global test view.
 
.Java: TestSignalGenerator addSignals(...) with condition building
[source,Java]
----
include::../../../main/java/srcJava_FpgaExmplBlinkingLed/org/vishia/fpga/exmplBlinkingLed/modules/BlinkingLedCt.java[tag=addSignals]
----

Here the output is triggered if the counter reaches the value 1, back counting before zero-crossing. 
Details of this are also used to present the common approach in link:Java2Vhdl_Approaches.html#testOutp[].

